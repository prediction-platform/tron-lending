# 委托计算逻辑修正

## 修正内容

### 问题描述
原来的委托计算逻辑是反的：金额越大，委托比例越小。这不符合业务逻辑。

### 修正后的逻辑
**金额越大，委托的能量应该越多**

## 新的委托计算规则

### 基于固定基数的计算方式

| 交易金额（SUN） | 对应 TRX | 基数 | 系数 | 说明 |
|----------------|----------|------|------|------|
| **< 1,000,000** | **< 1 TRX** | **跳过** | **跳过** | 小于1 TRX的交易跳过委托 |
| **1,000,000 - 100,000,000,000** | **1 - 100,000 TRX** | **15,000** | **10%** | 小额交易 |
| **100,000,000,000 - 1,000,000,000,000** | **100,000 - 1,000,000 TRX** | **15,000** | **25%** | 中额交易 |
| **> 1,000,000,000,000** | **> 1,000,000 TRX** | **15,000** | **50%** | 大额交易 |

### 单位换算关系
- **1 TRX = 1,000,000 SUN**
- **1 SUN = 0.000001 TRX**

## 代码实现

```go
// 金额<1trx
valueInt, err := strconv.ParseInt(data.Value, 10, 64)
if err != nil {
    c.log.Error("Failed to parse transaction amount", err, "value", data.Value)
    return fmt.Errorf("failed to parse transaction amount: %w", err)
}

if valueInt < 1000000 { // 小于 1 TRX (1,000,000 SUN)
    c.log.Info("Transaction amount is less than 1 TRX, skipping energy delegation", "id", data.ID, "value", data.Value)
    return nil
}

// 业务逻辑：基于交易金额设定固定基数计算委托数量
// 金额越大，委托的能量应该越多
var delegationBase int64 = 15000
var delegationMultiplier float64

// 基于 SUN 单位的阈值判断
// 1 TRX = 1,000,000 SUN
// 100,000 TRX = 100,000,000,000 SUN
// 1,000,000 TRX = 1,000,000,000,000 SUN
if valueInt > 1000000000000 { // 大于 1,000,000 TRX (1,000,000,000,000 SUN)
    delegationMultiplier = 0.5 // 50% 系数
} else if valueInt > 100000000000 { // 大于 100,000 TRX (100,000,000,000 SUN)
    delegationMultiplier = 0.25 // 25% 系数
} else {
    delegationMultiplier = 0.1 // 10% 系数
}

// 计算委托数量：基数 + (交易金额 * 系数)
delegationAmount := delegationBase + int64(float64(valueInt)*delegationMultiplier/10000) // 除以 10,000 来调整比例
```

## 实际计算示例

### 示例 1: 小于1 TRX交易
```go
value = "500000"  // 500,000 SUN = 0.5 TRX
// 结果：跳过委托，返回 nil
```

### 示例 2: 小额交易
```go
value = "50000000"  // 50,000,000 SUN = 50 TRX
availableEnergy = "10000"
// 计算：15000 + (50000000 * 0.1 / 10000) = 15000 + 500 = 15500
// 结果：受可用能量限制，委托 10000
```

### 示例 3: 中额交易
```go
value = "150000000000"  // 150,000,000,000 SUN = 150,000 TRX
availableEnergy = "20000"
// 计算：15000 + (150000000000 * 0.25 / 10000) = 15000 + 3750 = 18750
// 结果：受可用能量限制，委托 18750
```

### 示例 4: 大额交易
```go
value = "1500000000000"  // 1,500,000,000,000 SUN = 1,500,000 TRX
availableEnergy = "50000"
// 计算：15000 + (1500000000000 * 0.5 / 10000) = 15000 + 75000 = 90000
// 结果：受可用能量限制，委托 50000
```

## 业务逻辑说明

1. **小于1 TRX的交易**: 跳过委托，不进行任何操作
2. **小额交易（1 - 100,000 TRX）**: 基数 15,000 + 10% 系数
3. **中额交易（100,000 - 1,000,000 TRX）**: 基数 15,000 + 25% 系数
4. **大额交易（> 1,000,000 TRX）**: 基数 15,000 + 50% 系数

### 约束条件
- 小于1 TRX的交易跳过委托
- 委托数量不能超过可用能量
- 最小委托数量为 1000 能量，否则返回 0
- 所有计算基于 SUN 单位进行
- 固定基数为 15,000 能量

## 测试验证

运行测试命令：
```bash
go test ./internal/cronjob -v -run TestCalculateDelegationAmount
```

测试用例覆盖了所有四种交易类型和边界条件。

## 修正总结

✅ **修正前**: 基于可用能量百分比计算
✅ **修正后**: 基于固定基数 + 交易金额系数计算

✅ **新增功能**: 小于1 TRX的交易自动跳过委托

这样的逻辑更符合业务需求：
- 大额交易需要更多的能量委托来支持其交易活动
- 小额交易（< 1 TRX）不值得委托能量
- 使用固定基数确保最小委托量
- 系数随交易金额递增，体现金额越大委托越多的原则 